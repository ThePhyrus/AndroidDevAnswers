<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<resources>
    <string name="app_name">AndroidDevAnswers</string>
    <string name="hello_blank_fragment">Hello blank fragment</string>
    <string name="oop_principles">
        Абстракция. \n Инкапсуляция. \n Наследование. \n Полиморфизм. </string>
    <string name="polymorphism">Полиморфизм — одна из трех основных парадигм ООП. Если говорить 
        кратко, полиморфизм — это способность обьекта использовать методы производного класса, 
        который не существует на момент создания базового. </string>
    <string name="what_is_class">Класс определяет форму и сущность объекта и является логической 
        конструкцией, на основе которой построен весь язык Java. Наиболее важная особенность класса 
        состоит в том, что он определяет новый тип данных, которым можно воспользоваться для 
        создания объектов этого типа, т.е. класс — это шаблон (чертеж), по которому создаются 
        объекты (экземпляры класса). Для определения формы и сущности класса указываются данные, 
        которые он должен содержать, а также код, воздействующий на эти данные. Таким образом, 
        класс — это описание того, какими свойствами и поведением будет 
        обладать объект. А объект — это экземпляр с собственным состоянием этих свойств.</string>
    <string name="what_is_constructor">Constructor — это специальный метод, который автоматически 
        вызывается при создании объекта. Конструктор может принимать любые аргументы, как и любой 
        другой метод.</string>
    <string name="what_is_encapsulation">Инкапсуляция – это свойство системы, позволяющее 
        объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от 
        пользователя. Инкапсуляция связывает данные с манипулирующим ими кодом и позволяет 
        управлять доступом к членам класса из отдельных частей программы, предоставляя доступ 
        только с помощью определенного ряда методов, что позволяет предотвратить злоупотребление 
        этими данными. То есть класс должен представлять собой «черный ящик», которым можно 
        пользоваться, но его внутренний механизм защищен от повреждений.</string>
    <string name="what_is_inheritance">Одним из основополагающих принципов ООП является 
        наследование, который позволяет создатькласс (суперкласс), определяющий какие-то общие 
        черты набора классов, а затем этот общий класс может наследоваться другими, более 
        специализированными классами (подклассами), каждый из которых будет добавлять свои особые 
        характеристики. Подкласс наследует члены, определённые всуперклассе, добавляя к ним 
        собственные.
</string>
    <string name="what_is_solid">Роберт Мартин, для того, чтобы помочь всем желающим разрабатывать
        качественные ООП-приложения, разработал пять принципов объектно-ориентированного
        программирования и проектирования, говоря о которых, с подачи Майкла Фэзерса, используют
        акроним SOLID. \nВот как расшифровывается акроним SOLID: \n
        S: Single Responsibility Principle.\n
        O: Open-Closed Principle.\n
        L: Liskov Substitution Principle.\n
        I: Interface Segregation Principle.\n
        D: Dependency Inversion Principle.</string>
    <string name="what_is_single_responsibility_principle">Класс должен быть ответственен лишь за
        что-то одно. Если класс отвечает за решение нескольких задач, его подсистемы, реализующие
        решение этих задач, оказываются связанными друг с другом. Изменения в одной такой
        подсистеме ведут к изменениям в другой. \n
        Обратите внимание на то, что этот принцип применим не только к классам, но и к компонентам
        программного обеспечения в более широком смысле. \n
        Вот что по этому поводу говорит Стив Фентон: \n
        «Проектируя классы, мы должны стремиться к тому, чтобы объединять родственные компоненты,
        то есть такие, изменения в которых происходят по одним и тем же причинам. Нам следует
        стараться разделять компоненты, изменения в которых вызывают различные причины». \n
        Правильное применение принципа единственной ответственности приводит к высокой степени
        связности элементов внутри модуля, то есть к тому, что задачи, решаемые внутри него,
        хорошо соответствуют его главной цели.</string>
    <string name="what_is_open_closed_principle">Программные сущности (классы, модули, функции)
        должны быть открыты для расширения, но не для модификации. Добавить информации!</string>
    <string name="what_is_liskov_substitution_principle">empty</string>
    <string name="what_is_interface_segregation_principle">empty</string>
    <string name="what_is_dependency_inversion_principle">empty</string>
    <string name="empty">empty</string>
</resources>
